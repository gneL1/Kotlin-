# 基础语法
## 一、变量和函数
**基础数据类型：**  

Kotlin对象数据类型|数据类型说明|对应Java基本数据类型
:-|:-|:-|
Int|整型|int
Long|长整型|long
Short|短整型|short
Float|单精度浮点型|float
Double|双精度浮点型|double
Boolean|布尔型|boolean
Char|字符型|char
Byte|字节型|byte
### 1. 变量  
&emsp;&emsp;```val```(value),声明一个不可变的变量，初始复制后再也不能重新赋值，对应```final```  
&emsp;&emsp;```var```(variable),声明一个可变的变量。  
&emsp;&emsp;能用```val```时尽量用```val```。

```kotlin
fun main() {
  val a = 11;
  println("a = $a")
}
```

&emsp;&emsp;声明一个Int型变量：  
```kotlin
val a: Int = 10
```

&emsp;&emsp;对变量```a```进行运算，让```a```变大10倍  
```kotlin
val a : Int = 10
a = a*10
println("a = $a")
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/val_1.PNG)  
&emsp;&emsp;编译器会报错```Val cannot be reassigned```，因为```val```关键字声明的是一个不可变的变量，需要改成```var```关键字。  
```kotlin
var a : Int = 10
a *= 10
println("a = $a")
```

***

### 2. 函数  
&emsp;&emsp;```fun```是定义函数的关键字，```fun```后面的是函数名，函数名后面是一对括号，括号里面声明该函数接受什么参数，参数的数量可以是任意多个，参数的声明格式是 **参数名:参数类型**   ，不想接收参数就写一对空括号。  
&emsp;&emsp;参数括号后面的部分是可选的。声明该函数会返回什么类型的数据。不需要返回任何数据就不写。  
&emsp;&emsp;大括号之间的内容是函数体，在里面编写函数的具体逻辑。  
&emsp;&emsp;特别注意，函数的参数名名字不能相同，不然会报错。
```kotlin
fun methodName(param1: Int,param2: Int): Int{
  return 0
}
```

&emsp;&emsp;如果函数中只有一行代码，可以不用写方法体和```return```,直接写在函数定义的尾部，中间用等号连接：  
```kotlin
fun largerNumber(num1: Int,num2: Int): Int = max(num1,num2)
```
&emsp;&emsp;由于```max()```函数返回的是一个```Int```值，而在```largerNumber()```函数的尾部又使用了```=```连接```max()```函数，因此 **Kotlin** 可以推导出```largerNumber()```函数返回的也必然是一个```Int```值，这样就不用再显示的声明返回值类型，可以进一步简化成：    
```kotlin
fun largerNumber(num1: Int,num2: Int) = max(num1,num2)
```

***

## 二、程序的逻辑控制
### 1. if语句
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    var value = 0
    if (num1 > num2){
        value = num1
    }else{
        value = num2
    }
    return value
}
```
&emsp;&emsp;**Kotlin** 中的```if```语句是可以有返回值的，返回值就是```if```语句每一个条件中最后一样代码的返回值，上述代码可以简化成：  
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    val value = if (num1 > num2){
        num1
    }else{
        num2
    }
    return value
}
```
&emsp;&emsp;```if```语句使用每个条件的最后一行代码作为返回值，并将返回值赋值给```value```变量。由于没有重新赋值的情况，因此使用```val```关键字来声明```value```变量，最终将```value```变量返回。  
&emsp;&emsp;```value```实际上也是一个多余变量，可以直接将```if```语句返回：  
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    return if (num1 > num2){
        num1
    }else{
        num2
    }
}
```
&emsp;&emsp;当函数只有一行代码时，可以省略函数体部分，直接将这一行代码使用```=```连接在函数定义的尾部。  
```kotlin
fun largerNumber(num1:Int,num2:Int) = if (num1 > num2)
{
    num1
}else{
    num2
}
```
&emsp;&emsp;还可以再精简：  
```kotlin
fun largerNumber(num1:Int,num2:Int) = if (num1 > num2) num1 else num2
```

***

### 2. when语句
&emsp;&emsp;编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。  
```kotlin
fun getScore(name : String) = if (name == "Tom"){
    76
}else if (name == "Jim"){
    77
}else if (name == "Jack"){
    95
}else if (name == "Lily"){
    100
}else{
    0
}
```
&emsp;&emsp;上述代码过分冗余，使用```when```语句来修改：  
```kotlin
fun getScore(name : String) = when(name){
    "Tom" -> 86
    "Jim" -> 77
    "Jack" -> 95
    "Lily" -> 100
    else -> 0
}
```
* ```when```语句允许传入一个任意类型的参数，然后可以在```when```的结构体中定义一系列的条件，格式是：  
> 匹配值 -> { 执行逻辑 }  

&emsp;&emsp;当执行逻辑只有一行代码时，```{}```可以省略。  
&emsp;&emsp;  
* ```when```语句允许进行类型匹配：  
```kotlin
fun checkNumber(num : Number) =
    when(num){
        is Int -> "number is Int"
        is Double -> "number is Double"
        else -> "number not support"
    }
}
```
&emsp;&emsp;```is```关键字是类型匹配的核心，相当于 **Java** 中的```instanceof```关键字。```checkNumber()```接收一个```Number```类型的参数，这是 **Kotlin** 内置的一个抽象类，像```Int```、```Long```、```Float```、```Double```等与数字相关的类都是它的子类，所以这里就可以使用类型匹配来判断传入的参数到底属于什么类型。  
```kotlin
val v1 = 13.2
println("v1: ${checkNumber(v1)}")
val v2 = 265L   //这里使用的是Long类型
println("v2: ${checkNumber(v2)}")
```
执行结果：  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/when_1.PNG)  

* 可以不在```when```语句中传入参数：  
```kotlin
fun getScore(name : String) = when{
    name == "Tom" -> 86
    name == "Jim" -> 77
    name == "Jack" -> 95
    name == "Lily" -> 100
    else -> 0
}
```
&emsp;&emsp;这种用法是将判断的表达式完整地写在```when```的结构体中。**Kotlin** 中判断字符串或对象是否相等直接使用```==```关键字。  
&emsp;&emsp;有些场景必须使用这种写法。假设所有名字以```Tom```开头的人，他们的分数都是86分，这种场景如果用带参数的```when```语句来写就无法实现，而使用不带参数的```when```语句就可以写：  
```kotlin
fun getScore(name : String) = when{
    name.startsWith("Tom") -> 86
    name == "Jim" -> 77
    name == "Jack" -> 95
    name == "Lily" -> 100
    else -> 0
}
```

***

### 3. 循环语句
&emsp;&emsp;**Kotlin** 提供```while```循环和```for```循环，```while```循环和 **Java** 的一样，而```for```循环中，**Kotlin** 只有```for-in```循环。  

* 闭区间 **```..```**  
```kotlin
val range = 0..10
```
&emsp;&emsp;上述代码表示创建了一个0到10的区间，并且两边都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学方式表达就是```[0,10]```。  
&emsp;&emsp;```..```是创建两端闭区间的关键字，在```..```的两边指定区间的左右端点就可以创建一个区间。  
&emsp;&emsp;有了区间后，就可以通过```for-in```循环来遍历这个区间：  
```kotlin
for (i in 0..10){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_1.PNG)  

* 左闭右开区间 **```until```**  
```kotlin
val range = 0 until 10
```
&emsp;&emsp;上述代码表示创建了一个0到10的左闭右开区间，用数学表达式即```[0,10)```  
```kotlin
for (i in 0 until 10){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_2.PNG)  

* **```step```**  
&emsp;&emsp;默认情况下，```for-in```每次执行循环时会在区间范围内递增1，使用```step```可以以指定数值作为增长的步长，类似于```i++```的效果。  
```kotlin
//每次执行循环时，会在区间范围内递增2
//相当于java中for-i循环的i++效果
for (i in 0 until 10 step 2){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_3.PNG)  

* 降序区间 **```downTo```**  
```kotlin
for (i in 10 downTo 1){
    println(i)
}
```
&emsp;&emsp;上述代码实现了一个```[10,1]```的降序区间。  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_4.PNG)  

***

## apply的使用
&emsp;&emsp;```apply```函数的返回值是本身，在函数内部，可以任意调用对象的属性或方法或给属性赋值等。  
&emsp;&emsp;定义```People```类  
```kotlin
class People{
    var eye : Int = 2
    var leg : Int = 2

    fun say(){
        println("eyes=$eye, legs=$leg")
    }
}
```
&emsp;&emsp;创建```People```类实例，调用```apply```方法，可以看到省略了```p.```    
```kotlin
val p = People()
p.apply {
    eye = 3
    say()
    leg = 5
}.say()

p.say()
```
&emsp;&emsp;如果是```java```的话  
```java
public final void test() {
   People p = new People();
   p.setEye(3);
   p.hello();
   p.setLeg(5);
   p.hello();
   p.hello();
}
```



