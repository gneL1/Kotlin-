# 基础语法
## 一、变量和函数
**基础数据类型：**  

Kotlin对象数据类型|数据类型说明|对应Java基本数据类型
:-|:-|:-|
Int|整型|int
Long|长整型|long
Short|短整型|short
Float|单精度浮点型|float
Double|双精度浮点型|double
Boolean|布尔型|boolean
Char|字符型|char
Byte|字节型|byte
### 1. 变量  
&emsp;&emsp;```val```(value),声明一个不可变的变量，初始复制后再也不能重新赋值，对应```final```  
&emsp;&emsp;```var```(variable),声明一个可变的变量。  
&emsp;&emsp;能用```val```时尽量用```val```。

```kotlin
fun main() {
  val a = 11;
  println("a = $a")
}
```

&emsp;&emsp;声明一个Int型变量：  
```kotlin
val a: Int = 10
```

&emsp;&emsp;对变量```a```进行运算，让```a```变大10倍  
```kotlin
val a : Int = 10
a = a*10
println("a = $a")
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/val_1.PNG)  
&emsp;&emsp;编译器会报错```Val cannot be reassigned```，因为```val```关键字声明的是一个不可变的变量，需要改成```var```关键字。  
```kotlin
var a : Int = 10
a *= 10
println("a = $a")
```

***

### 2. 函数  
&emsp;&emsp;```fun```是定义函数的关键字，```fun```后面的是函数名，函数名后面是一对括号，括号里面声明该函数接受什么参数，参数的数量可以是任意多个，参数的声明格式是 **参数名:参数类型**   ，不想接收参数就写一对空括号。  
&emsp;&emsp;参数括号后面的部分是可选的。声明该函数会返回什么类型的数据。不需要返回任何数据就不写。  
&emsp;&emsp;大括号之间的内容是函数体，在里面编写函数的具体逻辑。  
&emsp;&emsp;特别注意，函数的参数名名字不能相同，不然会报错。
```kotlin
fun methodName(param1: Int,param2: Int): Int{
  return 0
}
```

&emsp;&emsp;如果函数中只有一行代码，可以不用写方法体和```return```,直接写在函数定义的尾部，中间用等号连接：  
```kotlin
fun largerNumber(num1: Int,num2: Int): Int = max(num1,num2)
```
&emsp;&emsp;由于```max()```函数返回的是一个```Int```值，而在```largerNumber()```函数的尾部又使用了```=```连接```max()```函数，因此 **Kotlin** 可以推导出```largerNumber()```函数返回的也必然是一个```Int```值，这样就不用再显示的声明返回值类型，可以进一步简化成：    
```kotlin
fun largerNumber(num1: Int,num2: Int) = max(num1,num2)
```

***

## 二、程序的逻辑控制
### 1. if语句
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    var value = 0
    if (num1 > num2){
        value = num1
    }else{
        value = num2
    }
    return value
}
```
&emsp;&emsp;**Kotlin** 中的```if```语句是可以有返回值的，返回值就是```if```语句每一个条件中最后一样代码的返回值，上述代码可以简化成：  
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    val value = if (num1 > num2){
        num1
    }else{
        num2
    }
    return value
}
```
&emsp;&emsp;```if```语句使用每个条件的最后一行代码作为返回值，并将返回值赋值给```value```变量。由于没有重新赋值的情况，因此使用```val```关键字来声明```value```变量，最终将```value```变量返回。  
&emsp;&emsp;```value```实际上也是一个多余变量，可以直接将```if```语句返回：  
```kotlin
fun largerNumber(num1:Int,num2:Int):Int{
    return if (num1 > num2){
        num1
    }else{
        num2
    }
}
```
&emsp;&emsp;当函数只有一行代码时，可以省略函数体部分，直接将这一行代码使用```=```连接在函数定义的尾部。  
```kotlin
fun largerNumber(num1:Int,num2:Int) = if (num1 > num2)
{
    num1
}else{
    num2
}
```
&emsp;&emsp;还可以再精简：  
```kotlin
fun largerNumber(num1:Int,num2:Int) = if (num1 > num2) num1 else num2
```

***

### 2. when语句
&emsp;&emsp;编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。  
```kotlin
fun getScore(name : String) = if (name == "Tom"){
    76
}else if (name == "Jim"){
    77
}else if (name == "Jack"){
    95
}else if (name == "Lily"){
    100
}else{
    0
}
```
&emsp;&emsp;上述代码过分冗余，使用```when```语句来修改：  
```kotlin
fun getScore(name : String) = when(name){
    "Tom" -> 86
    "Jim" -> 77
    "Jack" -> 95
    "Lily" -> 100
    else -> 0
}
```
* ```when```语句允许传入一个任意类型的参数，然后可以在```when```的结构体中定义一系列的条件，格式是：  
> 匹配值 -> { 执行逻辑 }  

&emsp;&emsp;当执行逻辑只有一行代码时，```{}```可以省略。  
&emsp;&emsp;  
* ```when```语句允许进行类型匹配：  
```kotlin
fun checkNumber(num : Number) =
    when(num){
        is Int -> "number is Int"
        is Double -> "number is Double"
        else -> "number not support"
    }
}
```
&emsp;&emsp;```is```关键字是类型匹配的核心，相当于 **Java** 中的```instanceof```关键字。```checkNumber()```接收一个```Number```类型的参数，这是 **Kotlin** 内置的一个抽象类，像```Int```、```Long```、```Float```、```Double```等与数字相关的类都是它的子类，所以这里就可以使用类型匹配来判断传入的参数到底属于什么类型。  
```kotlin
val v1 = 13.2
println("v1: ${checkNumber(v1)}")
val v2 = 265L   //这里使用的是Long类型
println("v2: ${checkNumber(v2)}")
```
执行结果：  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/when_1.PNG)  

* 可以不在```when```语句中传入参数：  
```kotlin
fun getScore(name : String) = when{
    name == "Tom" -> 86
    name == "Jim" -> 77
    name == "Jack" -> 95
    name == "Lily" -> 100
    else -> 0
}
```
&emsp;&emsp;这种用法是将判断的表达式完整地写在```when```的结构体中。**Kotlin** 中判断字符串或对象是否相等直接使用```==```关键字。  
&emsp;&emsp;有些场景必须使用这种写法。假设所有名字以```Tom```开头的人，他们的分数都是86分，这种场景如果用带参数的```when```语句来写就无法实现，而使用不带参数的```when```语句就可以写：  
```kotlin
fun getScore(name : String) = when{
    name.startsWith("Tom") -> 86
    name == "Jim" -> 77
    name == "Jack" -> 95
    name == "Lily" -> 100
    else -> 0
}
```

***

### 3. 循环语句
&emsp;&emsp;**Kotlin** 提供```while```循环和```for```循环，```while```循环和 **Java** 的一样，而```for```循环中，**Kotlin** 只有```for-in```循环。  

* 闭区间 **```..```**  
```kotlin
val range = 0..10
```
&emsp;&emsp;上述代码表示创建了一个0到10的区间，并且两边都是闭区间，这意味着0到10这两个端点都是包含在区间中的，用数学方式表达就是```[0,10]```。  
&emsp;&emsp;```..```是创建两端闭区间的关键字，在```..```的两边指定区间的左右端点就可以创建一个区间。  
&emsp;&emsp;有了区间后，就可以通过```for-in```循环来遍历这个区间：  
```kotlin
for (i in 0..10){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_1.PNG)  

* 左闭右开区间 **```until```**  
```kotlin
val range = 0 until 10
```
&emsp;&emsp;上述代码表示创建了一个0到10的左闭右开区间，用数学表达式即```[0,10)```  
```kotlin
for (i in 0 until 10){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_2.PNG)  

* **```step```**  
&emsp;&emsp;默认情况下，```for-in```每次执行循环时会在区间范围内递增1，使用```step```可以以指定数值作为增长的步长，类似于```i++```的效果。  
```kotlin
//每次执行循环时，会在区间范围内递增2
//相当于java中for-i循环的i++效果
for (i in 0 until 10 step 2){
    println(i)
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_3.PNG)  

* 降序区间 **```downTo```**  
```kotlin
for (i in 10 downTo 1){
    println(i)
}
```
&emsp;&emsp;上述代码实现了一个```[10,1]```的降序区间。  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/for_in_4.PNG)  

***

## 三、面向对象编程
&emsp;&emsp;右键包 -> New -> Kotlin File/Class，在弹出的对话框中输入```Person```。对话框在默认情况下自动选中的是创建一个```File```，```File```通常用于编写 **Kotlin** 顶层函数和扩展函数。  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/object_1.png)  
&emsp;&emsp;这里选择```Class```表示创建一个类，然后修改```Person```类的代码。  
```kotlin
class Person {
    var name = ""
    var age = 0

    fun eat(){
        println("$name is eating.He is $age years old.")
    }
}
```
### 1. 继承与构造函数
&emsp;&emsp;创建一个```Student```类，并在```Student```类中加入学号和年级这两个字段。  
```kotlin
class Student {
    var sno = ""
    var grade = 0
}
```
#### (1) 继承
&emsp;&emsp;现在想让```Studeng```类继承```Person```类：  
1. 使```Person```类可以被继承  
&emsp;&emsp;在 **Kotlin** 中所有非抽象类都是不可以被继承的，相当于 **Java** 中给类声明了 ```final``` 关键字。类和变量一样，最好都是不可变的，而一个类允许被继承的话，它无法预知子类会如何实现，因此可能就会存在一些未知的风险。  
&emsp;&emsp;之所以说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例，因此抽象类必须可以被继承才行，不然就没有意义了。  
```kotlin
open class Person {
    ......
}
```
&emsp;&emsp;加上```open```关键字之后，就是在主动告诉 **Kotlin** 编译器，```Person```这个类是专门为继承而设计的，这样```Person```类就允许被继承了。  

2. 让```Student```类继承```Person```类  
```kotlin
class Student : Person() {
    var sno = ""
    var grade = 0
}
```
&emsp;&emsp;在 **Java** 中继承的关键字是```extends```，而在 **Kotlin** 中变成了一个冒号。  

***

#### (2) 构造函数
&emsp;&emsp;**Kotlin** 将构造函数分成了两种：主构造函数和此构造函数。  
* 主构造函数  
&emsp;&emsp;每个类默认都会有一个不带参数的主构造函数，也可以显示地给它指明参数。主构造函数的特点是 **没有函数体** ，直接定义在类名的后面。  
```kotlin
class Student(val sno: String,val grade : Int) : Person() {
}
```
&emsp;&emsp;这里将学号和年级这两个字段都放到了主构造函数中，就表示在对```Student```类进行实例化的时候，必须传入构造函数中要求的所有参数。  
```kotlin
val student = Student("a105",6)
```
&emsp;&emsp;主构造函数没有函数体，如果想在主构造函数中编写一些逻辑，**Kotlin** 提供了一个```init```结构体，所有主构造函数中的逻辑都可以写在里面。  
```kotlin
class Student(val sno: String,val grade : Int) : Person() {
    init {
        println("学号是：$sno")
        println("年纪是：$grade")
    }
}
```
可以看到，当创建```Student```实例的时候，自动执行了```init```结构体里的代码：  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/construct_1.PNG)  
&emsp;&emsp;  
&emsp;&emsp;在 **Java** 继承特性中有个规定，子类中的构造函数必须调用父类中的构造函数。在 **Kotlin** 中，子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。  
&emsp;&emsp;上面```Person```类后面的一对空括号表示```Student```类的主构造函数在初始化的时候会调用```Person```类的无参构造函数，即使在无参数的情况下，这对括号也不能省略。  
&emsp;&emsp;  
修改```Person```类，将姓名和年龄都放到主构造函数中：  
```kotlin
open class Person (val name :String,val age : Int){
    .....
}
```
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/construct_2.PNG)  
&emsp;&emsp;可以看到，```Student```类此时报错，```Person```类后面的空括号表示要去调用```Person```类中无参的构造函数，但是```Person```类现在已经没有无参的构造函数了，所以会提示错误。  
&emsp;&emsp;  
&emsp;&emsp;解决方式就是在```Student```类的主构造函数中加上```name```和```age```这两个参数，再将这两个参数传给```Person```类的构造函数。  
```kotlin
class Student(val sno: String,val grade : Int,name:String,age:Int) : Person(name,age) {
    ......
}
```
&emsp;&emsp;注意，在```Student```类的主构造函数中增加```name```和```age```这两个字段时，不能再将它们声明成```val```，因为在主构造函数中声明成```val```或者```var```的参数将自动成为该类的字段，这会导致和父类中同名的```name```和```age```字段造成冲突。因此这里的```name```和```age```参数前面不加任何关键字，让它的作用域限定在主构造函数当中。  
&emsp;&emsp;对应的定义实例：  
```kotlin
 val student = Student("a105",6,"Jay",12)
```
&emsp;&emsp;  
* 次构造函数  
&emsp;&emsp;任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，只不过它是 **有函数体** 的。  
&emsp;&emsp;**Kotlin** 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数(包括间接调用)。  
```kotlin
class Student(val sno: String,val grade : Int,name:String,age:Int) : Person(name,age) {

    constructor(name: String,age: Int) : this("",0,name,age){
    }

    constructor() : this("",0){
    }
}
```
&emsp;&emsp;次构造函数是通过```construct```关键字来定义的，这里定义了两个次构造函数。第一个次构造函数接收```name```和```age```参数，然后通过```this```关键字调用了主构造函数，并将```sno```和```grade```这两个参数赋值成初始值。第二个次构造函数不接收任何参数，通过```this```关键字调用了刚才定义的第一个次构造函数，并将```name```和```age```也赋值成初始值，通过第一个次构造函数间接调用了主构造函数。  
&emsp;&emsp;实例化：  
```kotlin
val student1 = Student("a105",6,"Jay",12)
val student2 = Student("jack",9)
val student3 = Student()
```
&emsp;&emsp;  
&emsp;&emsp;还有一种特殊情况：类中只有次构造函数，没有主构造函数。  
&emsp;&emsp;当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。  
```kotlin
class Student: Person{

    constructor(name: String,age: Int) : super(name,age){
    }

    constructor() : this("",0){

    }
}
```
&emsp;&emsp;```Student```类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在```Student```类是没有主构造函数的。既然没有主构造函数，继承```Person```类的时候也就不需要再加上括号了。  
&emsp;&emsp;另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也就将第一个构造函数的```this```关键字换成了```super```关键字。  

***

### 2. 接口
&emsp;&emsp;**Java** 是单继承结构的语言，任何一个类最多只能继承一个父类，但是却可以实现任意多个接口， **Kotlin** 也是如此。  
* 接口的使用  
&emsp;&emsp;右键包 -> New -> Kotlin File/Class，在弹出的对话框中输入```Study```，创建类型选择```Interface```。  
```kotlin
//接口中的函数不要求有函数体
interface Study {
    fun readBooks()
    fun doHomeWork()
}
```
&emsp;&emsp;让```Student```类去实现```Study```接口：  
```kotlin
class Student(name:String,age:Int) : Person(name,age) ,Study{
    override fun readBooks() {
        println("$name is reading")
    }

    override fun doHomeWork() {
        println("$name is doing homework")
    }

}
```
&emsp;&emsp;使用```:```继承```Person```类，使用```,```实现```Study```接口。接口后面不用加上括号，因为它没有构造函数去调用。  
&emsp;&emsp;```Study```接口中定义了```readBooks()```和```doHomeWork()```两个待实现函数，因此```Student```类必须实现这两个函数。**Kotlin** 使用```override```关键字来重写父类或者实现接口中的函数。  
&emsp;&emsp;  
```kotlin
fun main(){
    val student = Student("Jack",12)
    doStudy(student)    
}
fun doStudy(study: Study){
    study.readBooks()
    study.doHomeWork()
}
```
&emsp;&emsp;首先创建了一个```Student```实例，将它传到```doStudy()```函数中。```doStudy()```函数接收一个```Study```类型的参数，由于```Student```类实现了```Study```接口，因此```Student```类的实例是可以传递给```doStudy()```函数的，接下来调用```Study```接口的```readBooks()```和```doHomework()```函数，这种就叫做面向接口编程，也可以称为多态。  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/Interface_1.PNG)  

* 对接口中的函数进行默认实现  
```kotlin
interface Study {
    fun readBooks()
    fun doHomeWork(){
        println("接口中实现了doHomeWork方法")
    }
}
```
&emsp;&emsp;给```doHomeWork()```函数加上了函数体，并且在里面打印了一行日志。如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现```Study```接口时，只会强制要求实现```readBooks()```函数，而```doHomeWork()```函数则可以自由选择实现或不实现，不实现时会自动使用默认的实现逻辑。  
&emsp;&emsp;现在回到```Student```类中，删除```doHomeWork()```函数，代码是不会提示错误的，而删除```readBooks()```函数则不行。  
```kotlin
class Student(name:String,age:Int) : Person(name,age) ,Study{
    override fun readBooks() {
        println("$name is reading")
    }

//    override fun doHomeWork() {
//        println("$name is doing homework")
//    }

}
```
运行结果：  
![图片示例](https://github.com/gneL1/Kotlin-/blob/master/photo/Base/Interface_2.PNG)  


## apply的使用
&emsp;&emsp;```apply```函数的返回值是本身，在函数内部，可以任意调用对象的属性或方法或给属性赋值等。  
&emsp;&emsp;定义```People```类  
```kotlin
class People{
    var eye : Int = 2
    var leg : Int = 2

    fun say(){
        println("eyes=$eye, legs=$leg")
    }
}
```
&emsp;&emsp;创建```People```类实例，调用```apply```方法，可以看到省略了```p.```    
```kotlin
val p = People()
p.apply {
    eye = 3
    say()
    leg = 5
}.say()

p.say()
```
&emsp;&emsp;如果是```java```的话  
```java
public final void test() {
   People p = new People();
   p.setEye(3);
   p.hello();
   p.setLeg(5);
   p.hello();
   p.hello();
}
```



